if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m002']=[{"name":"001-test.md","path":"002-学习/001-概念理解记忆/001-test.md","content":"### test","timestamp":1622628528854},{"name":"001-wrk.md","path":"002-学习/002-工具/001-测试工具/001-wrk.md","content":"![](assets/002/002/001/001-1621650410356.png)\n\nhttps://blog.csdn.net/ccccsy99/article/details/105958366\n\nhttps://cloud.tencent.com/developer/news/307600","timestamp":1622628528854},{"name":"001-mac-vim.md","path":"002-学习/002-工具/002-开发工具/001-mac-vim.md","content":"```shell\n使用neovim\nhttp://www.eryajf.net/4733.html\nhttps://www.cnblogs.com/cniwoq/p/13272746.html\ncoc.nvim配置\nhttps://www.cnblogs.com/hystill/p/13783183.html\n```","timestamp":1622628528854},{"name":"001-算法是什么.md","path":"002-学习/004-数据结构和算法/001-概念/001-算法是什么.md","content":"# 什么是算法\n算法是解决问题的一种方法, 给出了求解问题的步骤描述\n\n算法不用苛刻于具体的语法要求\n\n## 算法描述:\n1. 自然语言描述\n\n    容易，但是啰嗦，容易有二意性\n2. 图示(流程图, N-S图等)\n\n    直观清晰，但不宜实现\n3. 算法语言\n\n    严谨，简捷，容易程序实现\n4. 程序设计语言\n\n    可以直接运行，但太严格\n\n## 算法分析的方法\n1. 先验估计(事前估计)\n\n    根据算法的逻辑特征来估算\n2. 经验测试(事后计算)\n\n    选择样本数据,运行环境运行算法计算出空间，时间\n\n### 算法分析的一般步骤\n[语句频次]算法中一个基本操作执行的次数\n\n1. 计算出算法的各个语句的频度\n2. 统计出算法的语句频度和T(n)\n\n算法的时间复杂度:\n\nT(n) = O(f(n))\n\nf(n) 是问题规模n的一个函数,算法执行时间的增长率和f(n)的增长度相同\n\n\n###  最好时间复杂度，最坏时间复杂度，平均时间复杂度\n\n###  O 渐进算法分析\n问题规模变大,算法的效率如何变化，即增长率.\n这在确认算法是否值得实现时很有效\n\nT(n) = x^2 + 1\n\nT(n) = 100n + 1\n\n### 常见的时间复杂度\n执行次数函数举例|\t阶|\t非正式术语\n|-|-|-|\n|12|\tO(1)|\t常数阶|\n|2n+3|\tO(n)|\t线性阶|\n|3n2+2n+1|\tO(n2)|\t平方阶|\n|5log2n+20|\tO(logn)|\t对数阶|\n|2n+3nlog2n+19|\tO(nlogn)|\tnlogn阶|\n|6n3+2n2+3n+4|\tO(n3)|\t立方阶|\n|2n|\tO(2n)|\t指数阶|\n\nO(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)\n\n","timestamp":1622628528854},{"name":"002-什么是数据结构.md","path":"002-学习/004-数据结构和算法/001-概念/002-什么是数据结构.md","content":"## 什么是数据结构\n数据结构是数据元素的集合，还有这组数据之间的关系\n\n","timestamp":1622628528854},{"name":"003-逻辑结构-线性.md","path":"002-学习/004-数据结构和算法/001-概念/003-逻辑结构-线性.md","content":"## 线性逻辑结构\n\n### 线性表\nN个数据元素的有限序列，数据之间具有线性关系\n> 线性关系\n除了第一个元素外，每个元素有且仅有一个前驱\n除了最后一个元素外，每个元素有且仅有一个后继\n\n### 线性表的分类\n#### 按数据元素分\n1. 一般线性表\n2. 字符串\n3. 数组\n   > 具有同一种类型的数据元素的集合\n4. 广义表\n   > 数据元素之间不一定是同一种类型,元素之间的关系特殊\n\n#### 按实施操作分\n1. N元组\n > 不能进行插入,删除\n2. 一版线性表\n > 可以在任何位置插入，删除\n3. 堆栈\n > 只能在一端插入，删除\n4. 队列\n > 插入在一端，删除在另一端\n5. 双端队列\n > 在两端可以插入，删除","timestamp":1622628528854},{"name":"004-线性表-顺序存储.md","path":"002-学习/004-数据结构和算法/001-概念/004-线性表-顺序存储.md","content":"### 顺序存储结构\n1. 存储方式\n> 用一组地址连续的存储单元依次存储线性表的各个元素\n2. 优点\n> 可以随机存取\n3. 特点\n> 1. 存储空间必须是连续的,预分配\n> 2. 逻辑顺序和物理顺序一致，用物理上的相邻表示逻辑上的线性关系\n> 3. 任意相邻元素之间无空闲空间，且距离相聚l\n> 4. 已知基地址，可以计算出任意元素的存储地址","timestamp":1622628528854},{"name":"005-线性表-链式存储结构.md","path":"002-学习/004-数据结构和算法/001-概念/005-线性表-链式存储结构.md","content":"### 链式存储结构\n#### 存储方式\n> 用任意的存储单元来存放线性表的各个元素\n> 数据域 + 指针域\n\n#### 特点\n1. 存储空间不一定连续\n2. 逻辑关系由指针提现\n3. 逻辑上相邻，物理上不一定相邻\n4. 非随机存储(顺序存储), 即访问任意一个元素的时间不同\n\n#### 单链式存储结构\n> 存放元素的同时，存放其后继(或者前驱)元素的信息\n\n#### 循环单链式存储结构\n> 最后一个元素的指针域存储第一个元素的地址\n\n#### 双联表存储结构\n> 存放元素的同时，存放其前驱和后继的元素的信息\n\n#### 循环双链式存储结构\n\n> 第一个元素的前驱指向最后一个元素\n> 最后一个元素的后继指向第一个元素\n\n#### 头结点\n> 头结点数据域不存放任何数据，但是指针语存放的是第一个元素的存储地址\n\n\n","timestamp":1622628528854},{"name":"001-container预置内容如何加载.md","path":"002-学习/005-语言/001-php/001-框架/001-hyperf/001-container预置内容如何加载.md","content":"### container容器是如何工作的\n#### definitionSource\n```shell\nnew Container()会传入参数(new DefinitionSourceFactory(true))()\nDefinitionSourceFactory的__invoke方法返回\\Hyperf\\Di\\Definition\\DefinitionSource对象\nContainer对象构造时候将传入DefinitionSource对象对象作为属性definitionSource的值\n```\n\n#### $resolvedEntries属性\n> 已经解析项的映射\n\n\n\n#### fetchedDefinitions属性\n> 已经获取的定义的映射\n\n\n#### get方法的实现  get($name)\n1. 从resolvedEntries属性中获取是否有对应的项目，有则返回\n2. 如果还没解析过，调取$this->make($name)方法并返回\n\n#### make方法的实现\n> make的作用是解析一下该容器，类似get，但是每次都会重新解析\n1. getDefinition获取定义\n2. 调用definitionResolver重新解析容器\n\n#### getDefinition($name)  从本地缓存中获取容器的定义\n```shell\nDefinitionSource对象在构造的时候，传入了一批dependencies用于设置对象的source，来获取下对应的定义\n```\n\n#### DefinitionSourceFactory的__invoke中的$configFromProviders[\'dependencies\']如何获取\n```shell\n\\Hyperf\\Config\\ProviderConfig::load()的实现\n\\Hyperf\\Utils\\Composer::getMergedExtra(\'hyperf\')[\'config\'] ?? []\n这块的代码说白了是读取项目下的composer.lock,然后json_decode再构造为\\Hyperf\\Utils\\Collection对象，用于进一步使用\n读取composer.lock中所有extra里的hyperf项的config，然后返回数组作为预定义项\n说白了就是获取vendor里的所有configProvider的dependencies项组合为数组，作为预定义项\n```","timestamp":1622628528854}]